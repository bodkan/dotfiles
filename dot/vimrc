""""""""""""""""""""""""""""""""""""""""""""""""""
" General settings
""""""""""""""""""""""""""""""""""""""""""""""""""

let mapleader=" "
let maplocalleader="\\"

set history=500

syntax enable
filetype plugin on
filetype indent on

" auto read when a file is changed from the outside
set autoread
autocmd FocusGained,BufEnter * silent! checktime

set autowrite

" number of lines to the cursor when moving vertically using j/k
set scrolloff=5

set number relativenumber

set wildmenu
set wildmode=longest:list,full
set wildignore+=*.o,*~,*.pyc,*/.git/*,*/.DS_Store
set wildignorecase

set ruler

set cmdheight=1

set hidden

set backspace=eol,start,indent

set whichwrap+=<,>,h,l

set ignorecase
set smartcase
set incsearch
set nohlsearch

" show partial commands as they are typed
set showcmd

" show highlight of matching brackets
set showmatch

" how many tenths of a second to blink when matching brackets
set matchtime=2

set novisualbell

" how long to wait for further keys
set timeoutlen=500

" encoding displayed
set encoding=utf8
" encoding written
set fileencoding=utf-8

" always show the status line
set laststatus=2

set nobackup
set nowritebackup
set noswapfile

set wrap

" save undo trees in files
set undofile
set undodir=~/.vim/undo
set undolevels=10000

set path+=**

set regexpengine=0

" break lines at word boundaries
set linebreak

set splitbelow
set splitright

highlight VertSplit cterm=NONE guifg=NONE

" automatically generate tags file for given filetypes
if !empty(expand(glob("tags")))
    autocmd BufWritePost *.py,*.R,*.Rmd silent! !ctags -o newtags -R .; mv newtags tags &
end

" in command mode, use normal ignorecase, not smartcase
augroup dynamic_smartcase
    autocmd!
    autocmd CmdLineEnter : set nosmartcase
    autocmd CmdLineLeave : set smartcase
augroup END

augroup terminal_behavior
    autocmd!
    " no line numbers in the terminal ever
    autocmd TerminalOpen * setlocal nonumber norelativenumber
augroup END

" taken from :help last-position-jump
augroup RestoreCursor
  autocmd!
  autocmd BufReadPost *
    \ let line = line("'\"")
    \ | if line >= 1 && line <= line("$") && &filetype !~# 'commit'
    \      && index(['xxd', 'gitrebase'], &filetype) == -1
    \      && !&diff
    \ |   execute "normal! g`\""
    \ | endif
augroup END

" use spaces instead of tabs
set expandtab

" pressing TAB respects context
set smarttab

" one TAB is four characters wide for everything...
set shiftwidth=4
set tabstop=4
set softtabstop=4
" ... except R files
autocmd FileType r :setlocal sw=2 ts=2 sts=2
let g:r_indent_align_args = 0

set autoindent
set smartindent

""""""""""""""""""""""""""""""""""""""""""""""""""
" Custom commands and shortcuts
""""""""""""""""""""""""""""""""""""""""""""""""""

" quick <esc>
inoremap kj <esc>

" toggle a breakpoint at the current line
nnoremap <silent> <leader>p :call ToggleBreakpoint()<cr>
nnoremap <silent> <leader>P :call ClearBreakpoints()<cr>

" :W is a sudo save
command! W execute 'w !sudo tee % > /dev/null' <bar> edit!

nnoremap <leader>n :set number! relativenumber!<cr>
nnoremap <leader>N :set relativenumber!<cr>

nnoremap <leader>h :set hlsearch!<cr>

" pressing * or # searches for the current visual selection
vnoremap <silent> * :<C-u>call SelectionAction('')<cr>/<C-R>=@/<cr><cr>
vnoremap <silent> # :<C-u>call SelectionAction('')<cr>?<C-R>=@/<cr><cr>

" vimgrep for visual selection
vnoremap <silent> <leader>g :call SelectionAction('vimgrep')<CR>
" replace for visual selection
vnoremap <silent> <leader>r :call SelectionAction('replace')<CR>

nnoremap <leader>q :botright copen<cr>
nnoremap <leader>Q :clist<cr>
nnoremap ]q :cnext<cr>
nnoremap [q :cprevious<cr>

nnoremap <leader>w :set wrap!<cr>

" find file in the root of the current project (if any)
nnoremap <leader>ff :edit <c-r>=FindRootDirectory()<cr>/**/*

nnoremap <leader>E :split $MYVIMRC<cr>
nnoremap <leader>S :source $MYVIMRC<cr>

augroup commenting_code
  autocmd!
  autocmd FileType r,python,sh               let b:comment_leader = '# '
  autocmd FileType c,cpp,java                let b:comment_leader = '// '
  autocmd FileType tex                       let b:comment_leader = '% '
  autocmd FileType mail                      let b:comment_leader = '> '
  autocmd FileType vim                       let b:comment_leader = '" '
augroup END
" ctrl + / to comment
noremap <silent> <leader>; :<c-b>silent <c-e>s/^/<c-r>=escape(b:comment_leader,'\/')<cr>/<cr>:nohlsearch<cr>:w<cr>
" ctrl + shift + / to uncomment
noremap <silent> <leader>' :<c-b>silent <c-e>s/^\V<c-r>=escape(b:comment_leader,'\/')<cr>//e<cr>:nohlsearch<cr>:w<cr>

""""""""""""""""""""""""""""""""""""""""""""""""""
" Windows, buffers, tabs
""""""""""""""""""""""""""""""""""""""""""""""""""

" quick jump to a buffer
nnoremap <leader>bb :ls<cr>:b<space>

" quick jump to the previous buffer
nnoremap <leader><tab> <c-^>

" quick jump to a buffer
nnoremap <leader>bo :browse oldfiles<cr>

" close the current buffer
nnoremap <leader>bd :bnext<cr>:bd#<cr>

" moving between buffers
nnoremap ]b :bnext<cr>
nnoremap [b :bprevious<cr>

" managing tabs
nnoremap <leader>te :tabedit<space>
nnoremap <leader>tc :tabnew<cr>
nnoremap <leader>td :tabclose<cr>

" moving between tabs
nnoremap ]t :tabnext<cr>
nnoremap [t :tabprevious<cr>

" toggle between the current and the last accessed tab
let g:lasttab = 1
nnoremap <leader><bs> :exe "tabn ".g:lasttab<cr>
autocmd TabLeave * let g:lasttab = tabpagenr()

" if a buffer is already open in another window/tab, switch to it
set switchbuf=useopen,usetab,newtab
" always show tabline
set showtabline=1

""""""""""""""""""""""""""""""""""""""""""""""""""
" Helper functions
""""""""""""""""""""""""""""""""""""""""""""""""""

" Feed a given string to the command line
function! CmdLine(str)
    call feedkeys(":" . a:str)
endfunction

" Select visually the word under cursor
function! SelectionAction(action) range
    let l:saved_reg = @"
    execute "normal! vgvy"

    let l:pattern = escape(@", "\\/.*'$^~[]")
    let l:pattern = substitute(l:pattern, "\n$", "", "")

    if a:action == 'vimgrep'
        call CmdLine("vimgrep '" . l:pattern . "' " )
    elseif a:action == 'replace'
        call CmdLine("%s" . '/'. l:pattern . '/')
    endif

    let @/ = l:pattern
    let @" = l:saved_reg
endfunction

" Find root of the current "project" (if any) based on the current open file
function! FindRootDirectory()
    let root = systemlist("git rev-parse --show-toplevel")[0]
    if v:shell_error
        return ""
    else
        return root
    endif
endfunction

let g:breakpoint_marker = " ##### breakpoint #####"

" Toggle `breakpoint()` (Python) or `browser()` (R) function call
function! ToggleBreakpoint()
    let l:line=getline('.')

    " does the current line already have a breakpoint?
    let l:has_breakpoint = match(line, g:breakpoint_marker)

    " if not, add a breakpoint matching the current buffer's language
    if has_breakpoint == -1
        if &filetype ==# 'python'
            execute "normal! obreakpoint()" .. g:breakpoint_marker .. "\<esc>^"
            write
        elseif &filetype ==# 'r'
            normal! "normal! obrowser()" .. g:breakpoint_marker .. "\<esc>^"
            write
        else
            echo "Not applicable for this filetype!"
        endif
    else
        " if yes, delete the breakpoint
        normal! 0ddk^
    endif
endfunction

" Remove all `breakpoint()` (Python) or `browser()` (R) function calls
function! ClearBreakpoints()
    let l:marker = ""
    " create a breakpoint marker matching the current buffer's language
    if &filetype ==# 'python'
        marker = "breakpoint\(\)" .. g:breakpoint_marker
    elseif &filetype ==# 'r'
        marker = "browser\(\)" .. g:breakpoint_marker
    endif

    " delete all such markers (and avoid spamming the register)
    if marker != ""
        execute "g/^.*" .. marker .. ".*$/d _"
        write
    else
        echo "Not applicable for this filetype!"
    endif
endfunction
